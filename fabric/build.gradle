plugins {
	id 'java'
	id 'eclipse'
	id 'fabric-loom'
	id 'com.modrinth.minotaur'
	id 'me.hypherionmc.cursegradle'
}

tasks.withType(Jar).configureEach {
	archivesBaseName = "${mod_name}-Fabric"
}

java {
	sourceCompatibility = java_version
	targetCompatibility = java_version
}

eclipse {
	project {
		name = "${mod_name}Fabric"
	}
}

sourceSets {
	main {
		java {
			compileClasspath += project(":common").sourceSets.api.output
		}
	}
}

dependencies {
	implementation project(":api")
	implementation project(":common")
	implementation project(":plugin")
	
	minecraft "com.mojang:minecraft:${minecraft_version}"
	mappings loom.officialMojangMappings()
	
	modImplementation "net.fabricmc:fabric-loader:${fabric_loader_version}"
	modImplementation "net.fabricmc.fabric-api:fabric-api:${fabric_version}"
	modImplementation("net.minecraftforge:forgeconfigapiport-fabric:${forgeconfigapiport_version}") {
		exclude(group: 'net.fabricmc.fabric-api')
	}
	modImplementation "mcp.mobius.waila:wthit:fabric-${wthit_version}"
	modImplementation "lol.bai:badpackets:fabric-${badpackets_version}"
	implementation 'com.electronwill.night-config:core:3.6.3'
	implementation 'com.electronwill.night-config:toml:3.6.3'
}

loom {
	mixin {
		defaultRefmapName.set("${mod_id}.refmap.json")
	}
	
	runs {
		client {
			client()
			setConfigName("${mod_name} Fabric Client")
			ideConfigGenerated(true)
			runDir("../run")
		}
		server {
			server()
			setConfigName("${mod_name} Fabric Server")
			ideConfigGenerated(true)
			runDir("../run")
		}
	}
}

tasks.named('processResources', ProcessResources).configure {
	outputs.upToDateWhen {
		false
	}
	
	from project(":common").sourceSets.main.resources
	
	inputs.property "version", mod_version
	inputs.property "mod_name", mod_name
	
	filesMatching('fabric.mod.json') {
		expand('version': mod_version)
	}
	
	filesMatching('pack.mcmeta') {
		expand('mod_name': mod_name)
	}
	
	duplicatesStrategy = 'exclude'
}

tasks.named('compileJava', JavaCompile).configure {
	source project(":api").sourceSets.main.allSource
	source project(":common").sourceSets.main.allSource
}

tasks.register('apiJar', Jar).configure {
	from project(":api").sourceSets.main.output
	from project(":api").sourceSets.main.allSource
	
	from (sourceSets.main.resources) {
		include 'fabric.mod.json'
	}
	
	inputs.property "version", mod_version
	
	filesMatching('fabric.mod.json') {
		expand('version': mod_version)
	}
	
	archiveClassifier = "API"
}

curseforge {
	apiKey = project.hasProperty("curse_api_key") ? curse_api_key : ''
	project {
		id = curse_project_id
		changelog = file('../changelog.txt').canRead() ? file('../changelog.txt').text : ''
		changelogType = 'text'
		releaseType = 'release'
		addGameVersion 'Fabric'
		fabric_compatible_minecraft_versions.split(",").each {
			addGameVersion(it)
		}
		mainArtifact(remapJar) {
			displayName = "${mod_name}-Fabric-${minecraft_version}-${mod_version}"
		}
		addArtifact apiJar
		relations {
			requiredDependency 'fabric-api'
			requiredDependency 'forge-config-api-port-fabric'
		}
	}
	options {
		javaVersionAutoDetect = false
		forgeGradleIntegration = false
	}
}

modrinth {
	token = project.hasProperty("modrinth_api_key") ? modrinth_api_key : ''
	projectId = modrinth_project_id
	versionName = "${mod_name}-Fabric-${minecraft_version}-${mod_version}"
	versionNumber = "${minecraft_version}-${mod_version}"
	changelog = file('../changelog.txt').canRead() ? file('../changelog.txt').text : ''
	versionType = 'release'
	uploadFile = remapJar
	fabric_compatible_minecraft_versions.split(",").each {
		gameVersions.add(it)
	}
	loaders = ['fabric']
	additionalFiles = [apiJar]
	dependencies {
		required.project 'fabric-api'
		required.project 'forge-config-api-port'
	}
}

tasks.build.finalizedBy("apiJar")